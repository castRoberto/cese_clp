library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

entity fir is

    generic (
	    C_TAPS    : natural := 36; 		-- cantidad de bits del dato
	    C_DATA_W  : natural := 12 		-- cantidad de bits de las direcciones de la LUT
	);

    port (
        clk     : in std_logic;
        rst     : in std_logic;
        x_in    : in unsigned (C_DATA_W - 1 downto 0);
        y_out   : out unsigned (C_DATA_W - 1 downto 0)
    );

end;

architecture fir_arc of fir is

    -- Coeficientes del filtro FIR precargados como enteros sin signo de 16 bits
    type t_coeff_array is array (0 to C_TAPS - 1) of signed (C_DATA_W - 1 downto 0);

    constant COEFF : t_coeff_array :=
        (to_signed (46, C_DATA_W),    to_signed (15, C_DATA_W),     to_signed (-70, C_DATA_W),    to_signed (-34, C_DATA_W),
         to_signed (140, C_DATA_W),   to_signed (81, C_DATA_W),     to_signed (-266, C_DATA_W),   to_signed (-174, C_DATA_W),
         to_signed (463, C_DATA_W),   to_signed (340, C_DATA_W),    to_signed (-760, C_DATA_W),   to_signed (-634, C_DATA_W),
         to_signed (1229, C_DATA_W),  to_signed (1192, C_DATA_W),   to_signed (-2118, C_DATA_W),  to_signed (-2582, C_DATA_W),
         to_signed (5049, C_DATA_W),  to_signed (14466, C_DATA_W),  to_signed (14466, C_DATA_W),  to_signed (5049, C_DATA_W),
         to_signed (-2582, C_DATA_W), to_signed (-2118, C_DATA_W),  to_signed (1192, C_DATA_W),   to_signed (1229, C_DATA_W),
         to_signed (-634, C_DATA_W),  to_signed (-760, C_DATA_W),   to_signed (340, C_DATA_W),    to_signed (463, C_DATA_W),
         to_signed (-174, C_DATA_W),  to_signed (-266, C_DATA_W),   to_signed (81, C_DATA_W),     to_signed (140, C_DATA_W),
         to_signed (-34, C_DATA_W),   to_signed (-70, C_DATA_W),    to_signed (15, C_DATA_W),     to_signed (46, C_DATA_W));

    -- Buffer circular para almacenar las muestras de entrada
    type t_buffer is array (0 to C_TAPS - 1) of unsigned (C_DATA_W - 1 downto 0);

    signal circular_buffer : t_buffer;

    signal buffer_index : integer range 0 to C_TAPS - 1 := 0;  -- indice del buffer circular

    signal acc : signed (C_DATA_W + C_TAPS - 1 downto 0);    -- Acumulador para la salida

    signal enable : std_logic;

begin

    gen_ena_inst: entity work.gen_ena
        generic map (
            N => 1000--6250
	    )
        port map (
            clk_i => clk,
            rst_i => rst,
            ena_i => '1',
            q_o	  => enable
	    );

    process (clk)

    begin

        if rising_edge(clk) then

            if rst = '1' then

                circular_buffer <= (others => (others => '0'));
                acc <= (others => '0');
                y_out <= (others => '0');
                buffer_index <= 0;

            elsif enable = '1' then

                -- Almacenar la nueva muestra en el buffer circular
                circular_buffer (buffer_index) <= x_in;

                -- Calcular la salida filtrada usando el buffer circular
                acc <= (others => '0');  -- Reiniciar el acumulador
                for i in 0 to C_TAPS - 1 loop
                    
                    acc <= acc + signed (COEFF(i)) * signed (circular_buffer ((i + buffer_index) mod C_TAPS));

                end loop;

                -- Actualizar el índice del buffer circular
                buffer_index <= (buffer_index + 1) mod C_TAPS;

                -- Asignación de la salida truncada a los bits correctos
                y_out <= unsigned (std_logic_vector (acc (C_DATA_W - 1 downto 0)));

            end if;
        
        end if;

    end process;

end;